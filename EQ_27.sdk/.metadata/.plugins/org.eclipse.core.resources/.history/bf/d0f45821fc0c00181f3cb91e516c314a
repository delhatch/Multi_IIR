#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xstatus.h"
#include "xil_mmu.h"
#include "xil_assert.h"
#include "xil_io.h"
#include "audio.h"
#include "math.h"
#include "sleep.h"

/* Definitions */
#define GPIO_DEVICE_ID  XPAR_AXI_GPIO_0_DEVICE_ID	/* GPIO device that LEDs are connected to */
#define LED 0xa5									/* Initial LED value - XX0000XX */
#define LED_DELAY 100000000							/* Software delay length */
#define LED_CHANNEL 1								/* GPIO port for LEDs */
#define printf xil_printf							/* smaller, optimised printf */
#define NUM_BANDS 2     /* Number of bands (IIR "instances") in the filter. Must be <= 30 */

XGpio Gpio;											/* GPIO Device driver instance for LEDs */

char str[100];
int send_a1, send_a2, send_b1, send_b2;
int i, filter, offset;

struct coefs {
	float a1, a2, b1, b2;
};

struct coefs set[NUM_BANDS];

// The set_coef() function calculates the a and b coefficients for the IIR filter bi-quad.
// f0 is the center frequency of the filter in Hz, and p is the gain.
void set_coef( struct coefs *this_set, float f0, float p);

void clear_coefs(); // Sets all coefficients for all bands to zero.

int main()
{
    init_platform();

    int Status;
	int led = LED; /* Hold current LED value. Initialise to LED definition */
//---------------  LEDS  --------------------------------------------------
	/* GPIO driver initialisation */
	Status = XGpio_Initialize(&Gpio, GPIO_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	/*Set the direction for the LEDs to output. */
	XGpio_SetDataDirection(&Gpio, LED_CHANNEL, 0x00);
	/* Write output to the LEDs. */
	XGpio_DiscreteWrite(&Gpio, LED_CHANNEL, led);
//--------------  END OF LEDS  ---------------------------------------------
	xil_printf("Entering Main\r\n");
	//Configure the IIC data structure
	IicConfig(XPAR_XIICPS_0_DEVICE_ID);

	//Configure the Audio Codec's PLL
	AudioPllConfig();

	//Configure the Line in and Line out ports.
	//Call LineInLineOutConfig() for a configuration that
	//enables the HP jack too.
	AudioConfigureJacks();

	xil_printf("ADAU1761 configured -----\n\r");

	clear_coefs();    // Set all coefficients for all bands to zero.

	set_coef( &set[0], 90, 2.0);
	set_coef( &set[1], 5000, 2.0);

// The code below sends new coefficients to the filter
	Xil_Out32( 0x43c00000, 0 );   // Mute audio going into the filters.

	// Set all coefficients in BRAM to 0 to clear the filter nodes, THEN change the coefficients.
	// Ensures stability.
	for( i=0; i<=480; i=i+4) {
	   Xil_Out32( (0x40000000+i), 0 );  // Assumes BRAM at address 0x4000_0000.
	}

	usleep(300);  // Wait for 300 uSec for filters to clear.

	// Send new coefficients to the filter
	for( filter=0; filter<=(NUM_BANDS-1); filter+=1) {
		offset = filter * 0x10;
		send_a1 = ( (signed int) (set[filter].a1 * 0x10000000) );
		Xil_Out32( 0x40000000 + offset, send_a1 );
		offset += 4;
		send_a2 = ( (signed int) (set[filter].a2 * 0x10000000) );
		Xil_Out32( 0x40000000 + offset, send_a2 );
		offset += 4;
		send_b1 = ( (signed int) (set[filter].b1 * 0x10000000) );
		Xil_Out32( 0x40000000 + offset, send_b1 );
		offset += 4;
		send_b2 = ( (signed int) (set[filter].b2 * 0x10000000) );
		Xil_Out32( 0x40000000 + offset, send_b2 );
	}

/*
	// Now convert the floating point coef.s to fractional integers and send to the filter.
    send_a1 = ( (signed int) (set[0].a1 * 0x10000000) );
    //xil_printf("send_a1 = %x\n\r", send_a1);
    //send_a1 = 0;
    Xil_Out32( 0x40000000, send_a1 );

    send_a2 = ( (signed int) (set[0].a2 * 0x10000000) );
    //xil_printf("send_a2 = %x\n\r", send_a2);
    //send_a2 = 0;
    Xil_Out32( 0x40000004, send_a2 );

    send_b1 = ( (signed int) (set[0].b1 * 0x10000000) );
    //xil_printf("send_b1 = %x\n\r", send_b1);
    //send_b1 = 0;
    Xil_Out32( 0x40000008, send_b1 );

    send_b2 = ( (signed int) (set[0].b2 * 0x10000000) );
    //xil_printf("send_b2 = %x\n\r", send_b2);
    //send_b2 = 0;
    Xil_Out32( 0x4000000c, send_b2 );
//=========================================================================
    send_a1 = ( (signed int) (set[1].a1 * 0x10000000) );
    //xil_printf("send_a1 = %x\n\r", send_a1);
    //send_a1 = 0;
    Xil_Out32( 0x40000010, send_a1 );

    send_a2 = ( (signed int) (set[1].a2 * 0x10000000) );
    //xil_printf("send_a2 = %x\n\r", send_a2);
    //send_a2 = 0;
    Xil_Out32( 0x40000014, send_a2 );

    send_b1 = ( (signed int) (set[1].b1 * 0x10000000) );
    //xil_printf("send_b1 = %x\n\r", send_b1);
    //send_b1 = 0;
    Xil_Out32( 0x40000018, send_b1 );

    send_b2 = ( (signed int) (set[1].b2 * 0x10000000) );
    //xil_printf("send_b2 = %x\n\r", send_b2);
    //send_b2 = 0;
    Xil_Out32( 0x4000001c, send_b2 );
//==========================================================================
*/
    Xil_Out32( 0x43c00000, 0x1 );   // Un-mute audio input to filters.

    /*
    	// Debug out to terminal.
    	xil_printf(" b1 = ");
    	sprintf(str, "%f", set1.b1);
    	puts(str);
    	xil_printf(" b2 = ");
    	sprintf(str, "%f", set1.b2);
    	puts(str);
    	xil_printf(" a1 = ");
    	sprintf(str, "%f", set1.a1);
    	puts(str);
    	xil_printf(" a2 = ");
    	sprintf(str, "%f", set1.a2);
    	puts(str);
    */

    cleanup_platform();
    return 0;
}

// This function calculates the a and b coefficients for the IIR filter bi-quad.
// Note: The "a" terms are the feedback terms.
// Note: The polarity of "a" terms is reversed, so the IIR filter must add, not subtract.
// Note: The coefficients are set at one-half the actual value, so the IIR filter must
//          multiply them by two prior to using them.
// f0 is the center frequency of the filter in Hz, and p is the gain.
// For p, 0.001 = flat, 1.0 = +3 dB gain, 2.0 = +6 dB gain, -1.0 = -6 dB gain,...
// Note: Must enter the 'm' character to the SDK Project->Properties->Linker->Libraries (-l) section.
//       If, during linking, the trig functions below show up as "not found," this has not been done!
void set_coef( struct coefs *this_set, float f0, float p)
{
	float Fs, q0;
	float pi = 3.141592653;
	float t1, t2, t3, t4, t5, t6, t7, fn, q;

	//% Enter sample frequency
	Fs = 48828;
	//% Enter q of the filter. Is 4.3/3 for octave filter. 4.3/1 for one-third octave filter.
	q0 = 4.3;
	//% Enter center frequency of filter
	//f0 = 1000;
	//% Enter gain. 1.0 = +6dB. -0.5 = -3 dB. 0.1 = +0.6 dB.
	//p = 2.0;

	t1 = f0 * (1.0/(2.0*Fs));
	fn = tan(2*pi*t1);
	q = (2*pi)/fn;
	q = q * t1;
	q = log10(q)/log10(2);
	q = q*1.6;
	q = pow(2, q);
	q = q*q0;

	t1 = fn*fn;
	t2 = t1-1;
	t3 = t1+1;
	t1 = fn/(2*q);
	t4 = t1*(p-3);
	t5 = t1*(p+3);
	t6 = 1.0/(t3-t4);
	t7 = 1.0 / (t3 + t5);

	this_set->b1 = t2 * t7;
	this_set->b2 = (t3-t5) * t7 * 0.5;
	this_set->a1 = -t2 * t6;
	this_set->a2 = -(t3+t4) * t6 * 0.5;
}

void clear_coefs() {
	for( filter=0; filter<=(NUM_BANDS-1); filter+=1) {
		set[filter].a1 = 0.0;
		set[filter].a2 = 0.0;
		set[filter].b1 = 0.0;
		set[filter].b2 = 0.0;
	}
}

